 /************************************************************************************************************
 * @attention
 *
 * Firmware Disclaimer Information
 *
 * 1. The customer hereby acknowledges and agrees that the program technical documentation, including the
 *    code, which is supplied by Holtek Semiconductor Inc., (hereinafter referred to as "HOLTEK") is the
 *    proprietary and confidential intellectual property of HOLTEK, and is protected by copyright law and
 *    other intellectual property laws.
 *
 * 2. The customer hereby acknowledges and agrees that the program technical documentation, including the
 *    code, is confidential information belonging to HOLTEK, and must not be disclosed to any third parties
 *    other than HOLTEK and the customer.
 *
 * 3. The program technical documentation, including the code, is provided "as is" and for customer reference
 *    only. After delivery by HOLTEK, the customer shall use the program technical documentation, including
 *    the code, at their own risk. HOLTEK disclaims any expressed, implied or statutory warranties, including
 *    the warranties of merchantability, satisfactory quality and fitness for a particular purpose.
 *
 * <h2><center>Copyright (C) Holtek Semiconductor Inc. All rights reserved</center></h2>
 ************************************************************************************************************/
//Generated by HT32CodeConfig V1.1.5 Build 250402
//-----------------------------------------------------------------------------
#include "UART0.h"
#include "GPIO.h"  // LED控制宏定义
//-----------------------------------------------------------------------------
// 函数前向声明
void UART0_ProcessFrame(u8 *data, u8 len);

//-----------------------------------------------------------------------------
__ALIGN4 _UART0_STRUCT rxd_comm0;
__ALIGN4 _UART0_STRUCT txd_comm0;

// 温度数据存储
float uart_env_temp = 0;   // 环境温度
float uart_self_temp = 0;  // 自身温度


//-----------------------------------------------------------------------------
void UART0_Configuration(void)
{
  USART_InitTypeDef USART_InitStruct;
  CKCU_PeripClockConfig_TypeDef CKCUClock = {{0}};
  CKCUClock.Bit.UART0   = 1;
  CKCUClock.Bit.AFIO    = 1;
  CKCUClock.Bit.PA      = 1;
  CKCU_PeripClockConfig(CKCUClock, ENABLE);

  GPIO_PullResistorConfig(HT_GPIOA, GPIO_PIN_3, GPIO_PR_UP);  //Turn on UxART Rx internal pull up resistor to prevent unknow state

  AFIO_GPxConfig(GPIO_PA, AFIO_PIN_2, AFIO_FUN_USART_UART);  // Config AFIO mode
  AFIO_GPxConfig(GPIO_PA, AFIO_PIN_3, AFIO_FUN_USART_UART);  // Config AFIO mode

  USART_InitStruct.USART_BaudRate = 115200;
  USART_InitStruct.USART_WordLength = USART_WORDLENGTH_8B;
  USART_InitStruct.USART_StopBits = USART_STOPBITS_1;
  USART_InitStruct.USART_Parity = USART_PARITY_NO;
  USART_InitStruct.USART_Mode = USART_MODE_NORMAL;
  USART_Init(HT_UART0, &USART_InitStruct);
  USART_RxCmd(HT_UART0, ENABLE);
  USART_TxCmd(HT_UART0, ENABLE);

  USART_IntConfig(HT_UART0, USART_INT_RXDR, ENABLE);

  NVIC_EnableIRQ(UART0_IRQn);
  UART0_init_buffer();
}

//-----------------------------------------------------------------------------
void UART0_init_buffer (void)
{
  rxd_comm0.read_pt = 0;
  rxd_comm0.write_pt = 0;
  rxd_comm0.cnt = 0;

  txd_comm0.read_pt = 0;
  txd_comm0.write_pt = 0;
  txd_comm0.cnt = 0;
}

//-----------------------------------------------------------------------------
void UART0_IRQHandler(void)
{
  // Tx, move data from buffer to UART FIFO
  if ((HT_UART0->SR) & USART_FLAG_TXC)
  {
    if (!txd_comm0.cnt)
    {
      USART_IntConfig(HT_UART0, USART_INT_TXC, DISABLE);
    }
    else
    {
      u16 i;
      for (i = 0; i < UART0_FIFO_LEN; i++)   //have FIFO?
      {
        USART_SendData(HT_UART0, txd_comm0.buffer[txd_comm0.read_pt]);
        txd_comm0.read_pt = (txd_comm0.read_pt + 1) % UART0_BUF_SIZE;
        txd_comm0.cnt--;
        if (!txd_comm0.cnt)
          break;
      }
    }
  }

  // Rx, move data from UART FIFO to buffer
  if ((HT_UART0->SR) & USART_FLAG_RXDR )
  {
    rxd_comm0.buffer[rxd_comm0.write_pt] = USART_ReceiveData(HT_UART0);

    rxd_comm0.write_pt = (rxd_comm0.write_pt + 1) % UART0_BUF_SIZE;
    rxd_comm0.cnt++;
  }
}

//-----------------------------------------------------------------------------
// 字符串转浮点数（支持小数）
float string_to_float(u8 *str, u8 len)
{
  float result = 0.0;
  float decimal = 0.0;
  u8 i = 0;
  u8 decimal_started = 0;
  float decimal_divisor = 10.0;

  for(i = 0; i < len; i++)
  {
    if(str[i] >= '0' && str[i] <= '9')
    {
      if(decimal_started)
      {
        decimal += (str[i] - '0') / decimal_divisor;
        decimal_divisor *= 10.0;
      }
      else
      {
        result = result * 10.0 + (str[i] - '0');
      }
    }
    else if(str[i] == '.')
    {
      decimal_started = 1;
    }
  }

  return result + decimal;
}

//-----------------------------------------------------------------------------
// 二进制协议解析函数（状态机）
//-----------------------------------------------------------------------------
void UART0_ParseProtocol(void)
{
  static u8 parse_state = 0;  // 0=等待帧头1, 1=等待帧头2, 2=读长度, 3=读数据
  static u8 frame_length = 0;
  static u8 frame_buffer[32];
  static u8 frame_index = 0;
  u8 rx_byte;

  while(rxd_comm0.cnt > 0)
  {
    // 读取一个字节
    rx_byte = rxd_comm0.buffer[rxd_comm0.read_pt];
    NVIC_DisableIRQ(UART0_IRQn);
    rxd_comm0.cnt--;
    NVIC_EnableIRQ(UART0_IRQn);
    rxd_comm0.read_pt = (rxd_comm0.read_pt + 1) % UART0_BUF_SIZE;

    switch(parse_state)
    {
      case 0:  // 等待帧头1 (0x5A)
        if(rx_byte == UART_FRAME_HEAD1)
        {
          parse_state = 1;
        }
        break;

      case 1:  // 等待帧头2 (0xA5)
        if(rx_byte == UART_FRAME_HEAD2)
        {
          parse_state = 2;
          frame_index = 0;
        }
        else
        {
          parse_state = 0;  // 重新开始
        }
        break;

      case 2:  // 读取长度字节
        frame_length = rx_byte;
        if(frame_length > 0 && frame_length < 32)
        {
          parse_state = 3;
          frame_index = 0;
        }
        else
        {
          parse_state = 0;  // 长度异常，重新开始
        }
        break;

      case 3:  // 读取数据字节
        frame_buffer[frame_index++] = rx_byte;
        
        if(frame_index >= frame_length)
        {
          // 接收完整帧，开始解析
          UART0_ProcessFrame(frame_buffer, frame_length);
          parse_state = 0;  // 重新开始
        }
        break;
    }
  }
}

//-----------------------------------------------------------------------------
// 处理完整的数据帧（接收温度数据）
//-----------------------------------------------------------------------------
void UART0_ProcessFrame(u8 *data, u8 len)
{
  u8 cmd;
  u8 subcmd;
  u16 temp_value;
  u8 temp_type;
  float temp_float;
  u8 microwave_state;

  if(len < 2) return;  // 至少需要命令字节

  cmd = data[0];

  switch(cmd)
  {
    case CMD_DATA_QUERY:  // 0x82 - 数据查询/上报
      if(len < 2) break;
      subcmd = data[1];

      if(subcmd == SUBCMD_TEMP)  // 0x30 - 温度（接收）
      {
        if(len >= 5)
        {
          temp_type = data[2];

          // 数据格式: [82][30][类型][高字节][低字节]
          temp_value = (data[3] << 8) | data[4];
          temp_float = (float)temp_value / 10.0;  // 除以10得到一位小数

          if(temp_type == TEMP_TYPE_ENV)  // 0x20 - 环境温度（旁温）
          {
            if(temp_float <= 120.0)  // 范围检查
            {
              uart_env_temp = temp_float;
            }
          }
          else if(temp_type == TEMP_TYPE_SELF)  // 0x50 - 自身温度（杆温）
          {
            if(temp_float <= 120.0)  // 范围检查
            {
              uart_self_temp = temp_float;
            }
          }
        }
      }
      break;

    case CMD_CONTROL:  // 0x83 - 控制命令
      if(len >= 6)
      {
        subcmd = data[1];

        if(subcmd == SUBCMD_MICROWAVE)  // 0x10 - 微波控制
        {
          // 数据格式: [83][10][60][00][00][开关]
          microwave_state = data[5];

          if(microwave_state == 0x01)  // 开启微波
          {
            LED_STATUS2_ON;   // PB14亮（微波开启）
            LED_STATUS1_OFF;  // PB13灭
          }
          else if(microwave_state == 0x00)  // 关闭微波
          {
            LED_STATUS2_OFF;  // PB14灭
            LED_STATUS1_ON;   // PB13亮（微波关闭）
          }
        }
      }
      break;
  }
}

//-----------------------------------------------------------------------------
// 发送功率数据
// 参数: power - 功率值（整数）
// 协议: 5A A5 05 82 10 [高字节] [低字节]
//-----------------------------------------------------------------------------
void UART0_SendPower(u16 power)
{
  u8 frame[7];
  
  frame[0] = UART_FRAME_HEAD1;      // 0x5A
  frame[1] = UART_FRAME_HEAD2;      // 0xA5
  frame[2] = 0x05;                  // 长度（后续5字节）
  frame[3] = CMD_DATA_QUERY;        // 0x82
  frame[4] = SUBCMD_POWER;          // 0x10
  frame[5] = (power >> 8) & 0xFF;   // 高字节
  frame[6] = power & 0xFF;          // 低字节
  
  UART0_tx_data(frame, 7);
}

//-----------------------------------------------------------------------------
// 发送时间数据
// 参数: time_min - 时间值（分钟，整数，最大30）
// 协议: 5A A5 05 82 20 [高字节] [低字节]
//-----------------------------------------------------------------------------
void UART0_SendTime(u16 time_min)
{
  u8 frame[7];
  
  // 限制范围
  if(time_min > 30) time_min = 30;
  
  frame[0] = UART_FRAME_HEAD1;      // 0x5A
  frame[1] = UART_FRAME_HEAD2;      // 0xA5
  frame[2] = 0x05;                  // 长度（后续5字节）
  frame[3] = CMD_DATA_QUERY;        // 0x82
  frame[4] = SUBCMD_TIME;           // 0x20
  frame[5] = (time_min >> 8) & 0xFF;  // 高字节
  frame[6] = time_min & 0xFF;         // 低字节
  
  UART0_tx_data(frame, 7);
}

//-----------------------------------------------------------------------------
void UART0_tx_data(u8 *pt, u8 len)
{
  while(len--)
  {
    txd_comm0.buffer[txd_comm0.write_pt] = *pt++;
    txd_comm0.write_pt = (txd_comm0.write_pt + 1) % UART0_BUF_SIZE;
    NVIC_DisableIRQ(UART0_IRQn);
    txd_comm0.cnt++;
    NVIC_EnableIRQ(UART0_IRQn);
  }

  if(txd_comm0.cnt)
    USART_IntConfig(HT_UART0,  USART_INT_TXC , ENABLE);
}

//-----------------------------------------------------------------------------
void UART0_test(void)
{
  u8 i,test_array[8];
  for(i=0; i<8; i++)
  {
    test_array[i] = i;
  }
  UART0_tx_data(test_array, 8);
}

//-----------------------------------------------------------------------------
void UART0_SendNumber(u32 num)
{
  u8 buf[7];

  // 将数字转换为5位ASCII字符（限制在0-99999范围内）
  if(num > 99999) num = 99999;

  buf[0] = (num / 10000) % 10 + '0';
  buf[1] = (num / 1000) % 10 + '0';
  buf[2] = (num / 100) % 10 + '0';
  buf[3] = (num / 10) % 10 + '0';
  buf[4] = num % 10 + '0';
  buf[5] = '\r';
  buf[6] = '\n';

  UART0_tx_data(buf, 7);
}

//-----------------------------------------------------------------------------
void UART0_SendString(u8 *str)
{
  u8 len = 0;

  // 计算字符串长度
  while(str[len] != '\0')
  {
    len++;
  }

  // 发送字符串
  UART0_tx_data(str, len);
}

//-----------------------------------------------------------------------------


