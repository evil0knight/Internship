/************************************************************************************************************
* @attention
*
* Firmware Disclaimer Information
*
* 1. The customer hereby acknowledges and agrees that the program technical documentation, including the
*    code, which is supplied by Holtek Semiconductor Inc., (hereinafter referred to as "HOLTEK") is the
*    proprietary and confidential intellectual property of HOLTEK, and is protected by copyright law and
*    other intellectual property laws.
*
* 2. The customer hereby acknowledges and agrees that the program technical documentation, including the
*    code, is confidential information belonging to HOLTEK, and must not be disclosed to any third parties
*    other than HOLTEK and the customer.
*
* 3. The program technical documentation, including the code, is provided "as is" and for customer reference
*    only. After delivery by HOLTEK, the customer shall use the program technical documentation, including
*    the code, at their own risk. HOLTEK disclaims any expressed, implied or statutory warranties, including
*    the warranties of merchantability, satisfactory quality and fitness for a particular purpose.
*
* <h2><center>Copyright (C) Holtek Semiconductor Inc. All rights reserved</center></h2>
************************************************************************************************************/
//Generated by HT32CodeConfig V1.1.5 Build 250402
//-----------------------------------------------------------------------------

//=============================================================================
// 功能模块开关（通过宏定义控制）
//=============================================================================
#define ENABLE_UART     1       // 0=禁用UART模块  1=启用UART模块

//-----------------------------------------------------------------------------
#include "GPIO.h"      // GPIO引脚配置 (PB7, PB8作为软件I2C)
#include "BFTM0.h"     // 基本定时器 (1ms中断)
#if ENABLE_UART
#include "UART0.h"     // 串口通信
#endif
#include "Soft_I2c.h"  // 软件I2C + TM1640数码管驱动
#include "Key.h"       // 按键驱动（支持中断和消抖）

unsigned char brightness = 2;//亮度调节（1~8）

// 检查按键按下事件（自动清除）
u8 Key_IsPress(u8 key_num)
{
    if(Key_GetEvent(key_num) == KEY_EVENT_PRESS)
    {
        Key_ClearEvent(key_num);
        return 1;
    }
    return 0;
}

u8 Key_IsLong(u8 key_num)
{
    if(Key_GetEvent(key_num) == KEY_EVENT_LONG)
    {
        Key_ClearEvent(key_num);
        return 1;
    }
    return 0;
}

u8 Key_IsRelease(u8 key_num)
{
    if(Key_GetEvent(key_num) == KEY_EVENT_RELEASE)
    {
        Key_ClearEvent(key_num);
        return 1;
    }
    return 0;
}


int main(void)
{
    // 本地控制数据
    float power = 0;        // 功率（本地设置，通过UART发送）
    float time_min = 0;     // 时间（本地设置，通过UART发送）
    
#if !ENABLE_UART
    // UART禁用时使用本地温度变量（用于测试）
    float env_temp = 0;     // 环境温度（本地变量）
    float self_temp = 0;    // 自身温度（本地变量）
#endif
    
    unsigned char brightness = 2;
    volatile u32 i;

    // 系统初始化
    GPIO_Configuration();
    BFTM0_Configuration();
#if ENABLE_UART
    UART0_Configuration();
#endif
    Key_Configuration();

    TM1640_Init();
    LED_STATUS2_OFF;
    LED_STATUS1_OFF;
    LED_ERROR_OFF;

    // 延时让系统稳定（等待GPIO电平稳定）
    for(i = 0; i < 500000; i++);

    // 清除所有按键事件（防止上电时误触发）
    Key_ClearEvent(KEY0);
    Key_ClearEvent(KEY1);
    Key_ClearEvent(KEY2);
    Key_ClearEvent(KEY3);
    Key_ClearEvent(KEY4);

    // 初始显示一次（确保数据正确）
#if ENABLE_UART
    TM1640_DisplayMultiData(power, time_min, uart_env_temp, uart_self_temp);
#else
    TM1640_DisplayMultiData(power, time_min, env_temp, self_temp);
#endif

    // 主循环
    while(1)
    {
#if ENABLE_UART
        // 实时接收并解析UART数据（接收温度信息）
        UART0_ParseProtocol();
#endif

        //=========================================================================
        // 按键功能定义（根据UART开关自动适配）
        //=========================================================================
        
#if ENABLE_UART
        // ========== UART启用模式：按键控制功率和时间（温度从UART接收）==========
        
        // KEY0 - 快速增加功率+10
        if(Key_IsPress(KEY0))
        {
            power += 1;
            if(power > 120) power = 120;
            UART0_SendPower((u16)power);
        }
        
        // KEY1 - 时间+1分钟
        if(Key_IsPress(KEY1))
        {
            time_min += 1;
            if(time_min > 30) time_min = 0;
            UART0_SendTime((u16)time_min);
        }

        // KEY2 - 功率+10
        if(Key_IsPress(KEY2))
        {
            power += 1;
            if(power > 120) power = 120;
            UART0_SendPower((u16)power);
        }

        // KEY3 - 功率-10
        if(Key_IsPress(KEY3))
        {
            power -= 1;
            if(power < 0) power = 0;
            UART0_SendPower((u16)power);
        }

        // KEY4 - 时间-1分钟
        if(Key_IsPress(KEY4))
        {
            time_min -= 1;
            if(time_min < 0) time_min = 0;
            UART0_SendTime((u16)time_min);
        }
        
#else
        // ========== UART禁用模式：按键测试所有显示数据 ==========
        
        // KEY0 - 环境温度+1（测试用）
        if(Key_IsPress(KEY0))
        {
            env_temp += 1;
            if(env_temp > 99) env_temp = 0;
        }
        
        // KEY1 - 时间+1
        if(Key_IsPress(KEY1))
        {
            time_min += 1;
            if(time_min > 30) time_min = 0;
        }

        // KEY2 - 功率+10
        if(Key_IsPress(KEY2))
        {
            power += 10;
            if(power > 120) power = 120;
        }

        // KEY3 - 功率-10
        if(Key_IsPress(KEY3))
        {
            power -= 10;
            if(power < 0) power = 0;
        }

        // KEY4 - 自身温度+1（测试用）
        if(Key_IsPress(KEY4))
        {
            self_temp += 1;
            if(self_temp > 99) self_temp = 0;
        }
#endif

        // 每100ms更新显示
        if(bftm0_ct >= 100)
        {
#if ENABLE_UART
            // UART模式：显示本地功率/时间 + UART接收的温度
            TM1640_DisplayMultiData(power, time_min, uart_env_temp, uart_self_temp);
#else
            // 本地模式：显示所有本地变量
            TM1640_DisplayMultiData(power, time_min, env_temp, self_temp);
#endif
            bftm0_ct -= 100;
        }
    }
}
