# 按键驱动使用说明

## 硬件连接
- **KEY0**: PB0 (上拉输入，按下为低电平)
- **KEY1**: PB1 (上拉输入，按下为低电平)
- **KEY2**: PB2 (上拉输入，按下为低电平)
- **KEY3**: PB3 (上拉输入，按下为低电平)
- **KEY4**: PB4 (上拉输入，按下为低电平)

## 功能特性
1. **硬件消抖**: 20ms消抖时间，有效过滤按键抖动
2. **中断触发**: 按键按下时触发EXTI中断，快速响应
3. **事件检测**: 支持按下、释放、长按事件检测
4. **长按功能**: 长按1000ms（1秒）触发长按事件

## 文件说明
- `Key.h` - 按键驱动头文件
- `Key.c` - 按键驱动实现文件

## 初始化步骤

### 1. 在main.c中包含头文件
```c
#include "Key.h"
```

### 2. 在main函数中初始化
```c
int main(void)
{
    GPIO_Configuration();   // 初始化GPIO（必须先调用）
    BFTM0_Configuration();  // 初始化定时器（用于按键扫描）
    Key_Configuration();    // 初始化按键中断和消抖

    // 其他初始化...
}
```

### 3. 定时器中断已自动配置
BFTM0定时器每1ms触发一次中断，自动调用`Key_Scan()`函数进行按键扫描和消抖。

## API函数说明

### 1. Key_Configuration()
**功能**: 初始化按键中断和消抖功能
**参数**: 无
**返回**: 无
**说明**: 配置5个按键的EXTI中断（下降沿触发）

### 2. Key_Scan()
**功能**: 按键扫描函数（自动在BFTM0中断中调用）
**参数**: 无
**返回**: 无
**说明**: 每1ms扫描一次，处理消抖和事件检测

### 3. Key_GetEvent(u8 key_num)
**功能**: 获取按键事件
**参数**: `key_num` - 按键编号(KEY0-KEY4)
**返回**: 按键事件类型
- `KEY_EVENT_NONE` - 无事件
- `KEY_EVENT_PRESS` - 按键按下事件
- `KEY_EVENT_RELEASE` - 按键释放事件
- `KEY_EVENT_LONG` - 长按事件

### 4. Key_ClearEvent(u8 key_num)
**功能**: 清除按键事件
**参数**: `key_num` - 按键编号(KEY0-KEY4)
**返回**: 无
**说明**: 处理完事件后必须调用此函数清除事件标志

### 5. Key_GetState(u8 key_num)
**功能**: 获取按键当前状态
**参数**: `key_num` - 按键编号(KEY0-KEY4)
**返回**: 按键状态
- `KEY_STATE_IDLE` - 空闲状态
- `KEY_STATE_PRESS` - 按下状态

## 使用示例

### 示例1: 检测短按事件
```c
void main_loop(void)
{
    unsigned char key_event;

    // 检测KEY0短按
    key_event = Key_GetEvent(KEY0);
    if(key_event == KEY_EVENT_PRESS)
    {
        LED_STATUS1_TOGGLE;  // 切换LED状态
        Key_ClearEvent(KEY0);  // 清除事件
    }
}
```

### 示例2: 检测长按事件
```c
void main_loop(void)
{
    unsigned char key_event;

    // 检测KEY0长按
    key_event = Key_GetEvent(KEY0);
    if(key_event == KEY_EVENT_LONG)
    {
        LED_ERROR_ON;  // 长按点亮错误灯
        Key_ClearEvent(KEY0);
    }
    else if(key_event == KEY_EVENT_RELEASE)
    {
        LED_ERROR_OFF;  // 释放时熄灭
        Key_ClearEvent(KEY0);
    }
}
```

### 示例3: 按键控制数值增减
```c
void main_loop(void)
{
    static float power = 0;
    unsigned char key_event;

    // KEY2增加功率
    key_event = Key_GetEvent(KEY2);
    if(key_event == KEY_EVENT_PRESS)
    {
        power += 10;
        if(power > 999) power = 999;
        Key_ClearEvent(KEY2);
    }

    // KEY3减少功率
    key_event = Key_GetEvent(KEY3);
    if(key_event == KEY_EVENT_PRESS)
    {
        power -= 10;
        if(power < 0) power = 0;
        Key_ClearEvent(KEY3);
    }
}
```

### 示例4: 主循环完整示例（见main.c）
```c
while(1)
{
    unsigned char key_event;

    // KEY0: 切换LED1，长按点亮错误灯
    key_event = Key_GetEvent(KEY0);
    if(key_event == KEY_EVENT_PRESS)
    {
        LED_STATUS1_TOGGLE;
        Key_ClearEvent(KEY0);
    }
    else if(key_event == KEY_EVENT_LONG)
    {
        LED_ERROR_ON;
        Key_ClearEvent(KEY0);
    }

    // KEY1: 切换LED2
    key_event = Key_GetEvent(KEY1);
    if(key_event == KEY_EVENT_PRESS)
    {
        LED_STATUS2_TOGGLE;
        Key_ClearEvent(KEY1);
    }

    // KEY2: 功率增加
    key_event = Key_GetEvent(KEY2);
    if(key_event == KEY_EVENT_PRESS)
    {
        power += 10;
        if(power > 999) power = 999;
        Key_ClearEvent(KEY2);
    }

    // KEY3: 功率减少
    key_event = Key_GetEvent(KEY3);
    if(key_event == KEY_EVENT_PRESS)
    {
        power -= 10;
        if(power < 0) power = 0;
        Key_ClearEvent(KEY3);
    }

    // KEY4: 亮度调节
    key_event = Key_GetEvent(KEY4);
    if(key_event == KEY_EVENT_PRESS)
    {
        brightness++;
        if(brightness > 8) brightness = 1;
        TM1640_SetBrightness(brightness);
        Key_ClearEvent(KEY4);
    }
}
```

## 配置参数说明

在`Key.h`中可以修改以下参数：

```c
#define KEY_DEBOUNCE_TIME   20      // 消抖时间（ms）默认20ms
#define KEY_LONG_PRESS_TIME 1000    // 长按时间（ms）默认1000ms
```

## 注意事项

1. **必须清除事件**: 处理完按键事件后，必须调用`Key_ClearEvent()`清除事件标志，否则事件会持续存在
2. **定时器依赖**: 按键扫描依赖BFTM0定时器，定时器周期必须为1ms
3. **中断优先级**: 如果系统中有多个中断，请合理配置EXTI和BFTM0的中断优先级
4. **GPIO配置**: 按键引脚已配置为上拉输入，按下时为低电平
5. **事件只触发一次**: 每个事件只会触发一次，直到按键状态改变

## 中断说明

按键驱动使用了以下中断：
- `EXTI0_1_IRQHandler` - 处理KEY0(PB0)和KEY1(PB1)
- `EXTI2_3_IRQHandler` - 处理KEY2(PB2)和KEY3(PB3)
- `EXTI4_15_IRQHandler` - 处理KEY4(PB4)

中断仅用于快速响应按键变化，实际的消抖和事件检测在`Key_Scan()`中完成。

## 工作流程

1. 按键按下 → 触发EXTI中断（快速响应）
2. BFTM0定时器每1ms调用`Key_Scan()`
3. `Key_Scan()`检测按键状态并进行消抖
4. 消抖通过后，设置相应的事件标志
5. 主循环通过`Key_GetEvent()`读取事件
6. 处理完事件后调用`Key_ClearEvent()`清除标志

## 性能参数

- **响应时间**: 中断响应<1us，消抖确认20ms
- **长按检测**: 1000ms
- **扫描周期**: 1ms
- **CPU占用**: 极低（仅在中断中扫描）
- **内存占用**: 每个按键约10字节

---
**版本**: 1.0
**日期**: 2026-01-07
**作者**: HT32F50020按键驱动
